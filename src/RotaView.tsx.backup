import { useState, useEffect, ReactElement } from "react";
import { useMutation, useQuery } from "convex/react";
import { api } from "../convex/_generated/api";
import { Id } from "../convex/_generated/dataModel";
import { PharmacistSelectionModal } from "./PharmacistSelectionModal";

const DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
const CLINIC_DAY_LABELS = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];

interface RotaViewProps {
  isViewOnly?: boolean;
  initialSelectedMonday?: string;
  initialRotaAssignments?: any[];
  initialRotaIdsByDate?: Record<string, Id<"rotas">>;
}

export function RotaView({
  isViewOnly = false,
  initialSelectedMonday = "",
  initialRotaAssignments = [],
  initialRotaIdsByDate = {}
}: RotaViewProps = {}): ReactElement {
  const pharmacists = useQuery(api.pharmacists.list) || [];
  const generateWeeklyRota = useMutation(api.rotas.generateWeeklyRota);
  const updateAssignment = useMutation(api.rotas.updateRotaAssignment);
  const publishRota = useMutation(api.rotas.publishRota);
  const clinics = useQuery(api.clinics.listClinics) || [];
  const directorates = useQuery(api.requirements.listDirectorates) || [];
  const [selectedClinicIds, setSelectedClinicIds] = useState<Array<Id<"clinics">>>([]);
  const [selectedPharmacistIds, setSelectedPharmacistIds] = useState<Array<Id<"pharmacists">>>(() => {
    // Preselect default pharmacists
    return (pharmacists.filter((p: any) => p.isDefaultPharmacist).map((p: any) => p._id) || []);
  });
  const [selectedMonday, setSelectedMonday] = useState(initialSelectedMonday);
  const [generatingWeekly, setGeneratingWeekly] = useState(false);
  const [showClinicSelection, setShowClinicSelection] = useState(false);
  const [showPharmacistSelection, setShowPharmacistSelection] = useState(false);
  const [rotaGenerated, setRotaGenerated] = useState(isViewOnly || false);
  const [isPublishing, setIsPublishing] = useState(false);
  const [publishSuccess, setPublishSuccess] = useState(false);
  // Track current user for tracking metadata when publishing
  const [currentUser, setCurrentUser] = useState<{name: string, email: string}>(() => {
    // Try to get user info from localStorage - use currentPharmacist which is the correct key
    const storedUser = localStorage.getItem('currentPharmacist');
    return storedUser ? JSON.parse(storedUser) : { name: 'Unknown User', email: '' };
  });
  
  // Update currentUser whenever localStorage changes
  useEffect(() => {
    const handleStorageChange = () => {
      const storedUser = localStorage.getItem('currentPharmacist');
      if (storedUser) {
        setCurrentUser(JSON.parse(storedUser));
      }
    };
    
    // Check if we need to update right away
    handleStorageChange();
    
    // Listen for changes
    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, []);
  const [pharmacistWorkingDays, setPharmacistWorkingDays] = useState<Record<string, string[]>>({});
  const allRotas = useQuery(api.rotas.listRotas) || [];
  const [rotaAssignments, setRotaAssignments] = useState<any[]>(initialRotaAssignments);
  const [assignmentHistory, setAssignmentHistory] = useState<any[][]>([initialRotaAssignments]);
  const [currentHistoryIndex, setCurrentHistoryIndex] = useState<number>(0);
  const [rotaIdsByDate, setRotaIdsByDate] = useState<Record<string, Id<"rotas">>>(initialRotaIdsByDate);
  const [rotaUnavailableRules, setRotaUnavailableRules] = useState<Record<string, { dayOfWeek: string, startTime: string, endTime: string }[]>>({});
  const [singlePharmacistDispensaryDays, setSinglePharmacistDispensaryDays] = useState<string[]>([]);
  const [pharmacistSearch, setPharmacistSearch] = useState("");
  const [selectedCell, setSelectedCell] = useState<{
    rotaId: Id<"rotas">,
    assignmentIndices: number[],
    currentPharmacistId: Id<"pharmacists"> | null,
    location: string,
    date: string,
    startTime?: string,
    endTime?: string,
    otherPharmacistIds?: Id<"pharmacists">[],  // Track other pharmacists in the same cell
    newAssignment?: {
      location: string,
      type: "ward" | "dispensary" | "clinic" | "management",
      startTime: string,
      endTime: string,
      isLunchCover?: boolean
    }
  } | null>(null);

  // For drag and drop functionality to swap pharmacists
  const [dragSource, setDragSource] = useState<{
    pharmacistId: Id<"pharmacists">,
    assignment: any,
    location: string,
    date: string,
    startTime: string,
    endTime: string
  } | null>(null);
  
  const [dragTarget, setDragTarget] = useState<{
    pharmacistId: Id<"pharmacists"> | null,
    assignment: any | null,
    location: string,
    date: string,
    startTime: string,
    endTime: string
  } | null>(null);

  // Log rotaAssignments changes
  useEffect(() => {
    console.log('[useEffect rotaAssignments] Rota assignments updated:', rotaAssignments);
  }, [rotaAssignments]);

  // Helper: Get all wards with directorate info
  const allWards = directorates.flatMap((d: any) => (d.wards || []).filter((w: any) => w.isActive).map((w: any) => ({...w, directorate: d.name})));

  // Define rota time slots
  const TIME_SLOTS = [
    { start: "09:00", end: "11:00" },
    { start: "11:00", end: "13:00" },
    { start: "13:00", end: "15:00" },
    { start: "15:00", end: "17:00" },
  ];

  // Helper: get assignments for a given day, ward, and slot
  function getWardAssignment(
    date: string,
    ward: string,
    slot: { start: string; end: string }
  ) {
    const found = rotaAssignments.find(a =>
      a.type === "ward" &&
      a.date === date &&
      a.location === ward &&
      a.startTime <= slot.start &&
      a.endTime >= slot.end
    );
    console.log('[getWardAssignment]', found ? "Found:" : "Not found:", { date, ward, slot, found });
    return found;
  }

  // Helper: get assignments for clinic for a given date and clinic
  function getClinicAssignment(
    date: string,
    clinicName: string
  ) {
    const found = rotaAssignments.find(a =>
      a.type === "clinic" &&
      a.date === date &&
      a.location === clinicName
    );
    
    console.log('[getClinicAssignment]', found ? "Found:" : "Not found:", { date, clinicName, found });
    return found;
  }

  // Helper: get assignments for dispensary for a given date and slot
  function getDispensaryAssignment(
    date: string,
    slot: { start: string; end: string }
  ) {
    // First try to find an exact match for the time slot
    const found = rotaAssignments.find(a =>
      a.date === date &&
      a.type === "dispensary" &&
      a.startTime === slot.start &&
      a.endTime === slot.end
    );
    
    if (found) {
      console.log('[getDispensaryAssignment] Found:', { date, slot, found });
      return found;
    } else {
      // Check if this is a lunch slot by trying to find a lunch cover assignment
      const lunchCover = rotaAssignments.find(a =>
        a.date === date &&
        a.type === "dispensary" &&
        a.isLunchCover === true &&
        a.startTime <= slot.end &&
        a.endTime >= slot.start
      );
      
      if (lunchCover) {
        console.log('[getDispensaryAssignment] Found lunch cover:', { date, slot, lunchCover });
        return lunchCover;
      }
      
      // If no exact match and not a lunch slot, check if there's a regular dispensary assignment
      // that overlaps with this slot (e.g., a pharmacist assigned for the whole day)
      const overlapping = rotaAssignments.find(a =>
        a.date === date &&
        a.type === "dispensary" &&
        !a.isLunchCover &&
        a.startTime <= slot.start &&
        a.endTime >= slot.end
      );
      
      if (overlapping) {
        console.log('[getDispensaryAssignment] Found overlapping:', { date, slot, overlapping });
        return overlapping;
      }
      
      console.log('[getDispensaryAssignment] Not found:', { date, slot });
      return undefined;
    }
  }

  // Helper: get pharmacist name
  function getPharmacistName(pharmacistId: string) {
    // Define a more complete type for pharmacist that includes our new fields
    type PharmacistWithDisplayName = {
      _id: Id<"pharmacists">;
      name: string;
      displayName?: string;
      firstName?: string;
      lastName?: string;
      [key: string]: any; // For other properties we don't need to specify here
    };
    
    const p = pharmacists.find((p: PharmacistWithDisplayName) => p._id === pharmacistId);
    if (!p) return "";
  
    // Use displayName if available, otherwise fall back to the legacy name field
    return p.displayName || p.name;
  }

  // Helper: Get unavailable pharmacists for a given day
  function getUnavailablePharmacists(dateStr: string) {
    const date = new Date(dateStr);
    const dayLabel = DAYS[date.getDay()];
    return pharmacists.filter((p: any) => {
      if (!p.notAvailableRules || !Array.isArray(p.notAvailableRules)) return false;
      // If any rule matches this day
      return p.notAvailableRules.some((rule: any) => rule.dayOfWeek === dayLabel);
    });
  }

  // Helper: Get unavailable pharmacists for a given day
  function isPharmacistNotAvailable(pharmacist: any, dayLabel: string, slot: { start: string, end: string }) {
    return getAllUnavailableRules(pharmacist).some((rule: any) =>
      rule.dayOfWeek === dayLabel && !(slot.end <= rule.startTime || slot.start >= rule.endTime)
    );
  }

  // Helper: get all unavailable rules (permanent + rota-specific)
  function getAllUnavailableRules(pharmacist: any) {
    return [
      ...(pharmacist.notAvailableRules || []),
      ...(rotaUnavailableRules[pharmacist._id] || [])
    ];
  }

  // Helper: get all unavailable rules (permanent + rota-specific)
  function addRotaUnavailableRule(pharmacistId: string, rule: { dayOfWeek: string, startTime: string, endTime: string }) {
    setRotaUnavailableRules(prev => {
      const rules = prev[pharmacistId] || [];
      return { ...prev, [pharmacistId]: [...rules, rule] };
    });
  }
  // Helper to remove a rota-specific unavailable rule
  function removeRotaUnavailableRule(pharmacistId: string, idx: number) {
    setRotaUnavailableRules(prev => {
      const rules = (prev[pharmacistId] || []).slice();
      rules.splice(idx, 1);
      return { ...prev, [pharmacistId]: rules };
    });
  }

  // Helper: check if a pharmacist has overlapping assignments (ward with clinic or dispensary)
  function hasOverlappingAssignments(
    pharmacistId: Id<"pharmacists">,
    date: string,
    timeSlot: { start: string; end: string }
  ) {
    // Check if pharmacist has a ward assignment for this time slot
    const wardAssignment = rotaAssignments.find(a =>
      a.type === "ward" &&
      a.date === date &&
      a.pharmacistId === pharmacistId &&
      a.startTime <= timeSlot.start &&
      a.endTime >= timeSlot.end
    );

    if (!wardAssignment) return false;

    // Check if pharmacist has a clinic assignment that overlaps with this time slot
    const clinicAssignment = rotaAssignments.find(a =>
      a.type === "clinic" &&
      a.date === date &&
      a.pharmacistId === pharmacistId &&
      a.startTime < timeSlot.end &&
      a.endTime > timeSlot.start
    );

    if (clinicAssignment) return true;

    // Check if pharmacist has a dispensary assignment that overlaps with this time slot
    const dispensaryAssignment = rotaAssignments.find(a =>
      a.type === "dispensary" &&
      a.date === date &&
      a.pharmacistId === pharmacistId &&
      a.startTime < timeSlot.end &&
      a.endTime > timeSlot.start
    );

    return !!dispensaryAssignment;
  }

  // Helper: get pharmacist cell color
  function getPharmacistCellClass(pharmacistId: string) {
    const p = pharmacists.find((p: any) => p._id === pharmacistId);
    if (!p) return '';
    switch (p.band) {
      case 'Dispensary Pharmacist':
        return 'bg-purple-100 text-purple-800 border-purple-300';
      case 'EAU Practitioner':
        return 'bg-blue-900 text-white border-blue-900';
      case '8a':
        return 'bg-green-700 text-white';
      case '7':
        return 'bg-green-500 text-white';
      case '6':
        return 'bg-green-100 text-green-800';
      default:
        return '';
    }
  }

  // --- LOGGING: Pharmacist Working Days Initialization Effect ---
  useEffect(() => {
    if (!pharmacists || pharmacists.length === 0) return;
    console.log('[Effect] pharmacists changed:', pharmacists);
    // Only initialize if pharmacistWorkingDays is empty
    if (Object.keys(pharmacistWorkingDays).length === 0) {
      const newWorkingDays = Object.fromEntries(
        pharmacists.map((p: any) => [
          p._id,
          Array.isArray(p.workingDays) ? p.workingDays : CLINIC_DAY_LABELS,
        ])
      );
      const isDifferent =
        JSON.stringify(pharmacistWorkingDays) !== JSON.stringify(newWorkingDays);
      console.log('[Effect] pharmacistWorkingDays empty, isDifferent:', isDifferent);
      if (isDifferent) {
        console.log('[Effect] Setting pharmacistWorkingDays:', newWorkingDays);
        setPharmacistWorkingDays(newWorkingDays);
      }
    }
    // eslint-disable-next-line
  }, [pharmacists]);

  // --- LOGGING: Clinics Preselect Effect ---
  useEffect(() => {
    if (clinics.length > 0 && selectedClinicIds.length === 0) {
      // Pre-select all clinics with includeByDefaultInRota === true
      const defaultClinicIds = clinics.filter(c => c.includeByDefaultInRota).map(c => c._id);
      setSelectedClinicIds(defaultClinicIds);
    }
  }, [clinics, selectedClinicIds.length]);

  // --- LOGGING: Pharmacist Selection Effect ---
  useEffect(() => {
    if (!pharmacists || pharmacists.length === 0) return;
    console.log('[Effect] pharmacists changed (selection):', pharmacists);
    const defaultIds = pharmacists.filter((p: any) => p.isDefaultPharmacist).map((p: any) => p._id);
    setSelectedPharmacistIds((prev: Array<Id<"pharmacists">>) => {
      if (JSON.stringify(prev) !== JSON.stringify(defaultIds)) {
        return defaultIds;
      }
      return prev;
    });
  }, [pharmacists]);

  // --- LOGGING: RotaAssignments Setter with history tracking ---
  function setRotaAssignmentsLogged(newAssignments: any[]) {
    console.log('[setRotaAssignments] called. New assignments:', newAssignments);
    setRotaAssignments((prev: any[]) => {
      const isDifferent = JSON.stringify(prev) !== JSON.stringify(newAssignments);
      console.log('[setRotaAssignments] prev:', prev, 'isDifferent:', isDifferent);
      
      if (isDifferent) {
        // Update history when assignments change
        setAssignmentHistory(history => {
          // Remove any future history if we're not at the most recent state
          const newHistory = history.slice(0, currentHistoryIndex + 1);
          // Add the new state to history
          return [...newHistory, JSON.parse(JSON.stringify(newAssignments))];
        });
        
        // Update current history index
        setCurrentHistoryIndex(index => index + 1);
        
        return newAssignments;
      } else {
        return prev;
      }
    });
  }

  // --- LOGGING: Pharmacist Working Days Setter ---
  function setPharmacistWorkingDaysLogged(newWorkingDays: Record<string, string[]>) {
    console.log('[setPharmacistWorkingDays] called. New working days:', newWorkingDays);
    setPharmacistWorkingDays(newWorkingDays);
  }

  // --- LOGGING: handleSetPharmacistWorkingDays ---
  function handleSetPharmacistWorkingDays(pharmacistId: string, day: string, checked: boolean) {
    setPharmacistWorkingDays(prev => {
      const oldDays = prev[pharmacistId] || [];
      let newDays: string[];
      if (checked) {
        newDays = [...oldDays, day];
      } else {
        newDays = oldDays.filter(d => d !== day);
      }
      return { ...prev, [pharmacistId]: newDays };
    });
  }
  
  // Helper: Create a new assignment safely through the API
  const createOrUpdateAssignment = async (rotaId: Id<"rotas">, assignment: any, pharmacistId: Id<"pharmacists">) => {
    try {
      // Always create a new assignment instead of trying to update by index (which can cause out-of-bounds errors)
      await updateAssignment({
        rotaId,
        assignmentIndex: -1, // Create new assignment instead of updating
        pharmacistId,
        newAssignment: {
          location: assignment.location,
          type: assignment.type,
          startTime: assignment.startTime,
          endTime: assignment.endTime,
          isLunchCover: assignment.isLunchCover
        }
      });
      return true;
    } catch (error) {
      console.error('[createOrUpdateAssignment] Error:', error);
      return false;
    }
  };
  
  // Handle undo action - go back to previous state
  const handleUndo = async () => {
    if (currentHistoryIndex > 0) {
      // Go back one step in history
      const prevIndex = currentHistoryIndex - 1;
      const prevAssignments = assignmentHistory[prevIndex];
      
      console.log(`[handleUndo] Going back to history index ${prevIndex}`);
      
      // Instead of directly setting the assignments, we need to recreate them through the API
      // to ensure the backend state matches
      try {
        // First, update the UI state to show we're processing
        setRotaAssignments(prevAssignments);
        setCurrentHistoryIndex(prevIndex);
        
        // No need to call API here - we'll let the normal data sync mechanisms update the data
        // The next data fetch will pull the correct assignments anyway
      } catch (error) {
        console.error('[handleUndo] Error:', error);
      }
    } else {
      console.log('[handleUndo] Already at oldest state, cannot undo further');
    }
  };
  
  // Handle reset - return to original algorithm-generated rota
  const handleReset = async () => {
    if (assignmentHistory.length > 0) {
      // Reset to the first state in history (the original algorithm-generated rota)
      const originalAssignments = assignmentHistory[0];
      
      console.log('[handleReset] Resetting to original algorithm-generated rota');
      console.log('[handleReset] Original assignments count:', originalAssignments.length);
      
      // Instead of directly setting the assignments, first update our UI state
      setRotaAssignments(originalAssignments);
      
      // Keep the original state as the first item but clear all other history
      setAssignmentHistory([originalAssignments]);
      setCurrentHistoryIndex(0);
      
      // Rather than trying to directly update assignments in the backend (which could 
      // cause index out of bounds errors), we'll use regenerateRota to reset the entire rota
      try {
        if (selectedMonday) {
          console.log('[handleReset] Regenerating rota to ensure backend consistency');
          // Note: regenerateRota=true tells the backend to regenerate the entire rota
          await handleGenerateWeeklyRota(singlePharmacistDispensaryDays, true);
        }
      } catch (error) {
        console.error('[handleReset] Error regenerating rota:', error);
      }
    } else {
      console.log('[handleReset] No history available, cannot reset');
    }
  };

  // --- LOGGING: RotaAssignments Population Effect ---
  useEffect(() => {
    console.log('[useEffect][populate rotaAssignments] allRotas changed. Finding new assignments...');
    if (allRotas.length > 0) {
      // Create a map of date to rota ID
      const newRotaIdsByDate: Record<string, Id<"rotas">> = {};
      // Collect all assignments from all rotas
      const allAssignments: any[] = [];

      for (const rota of allRotas) {
        // Normalize date to YYYY-MM-DD format
        const dateObj = new Date(rota.date);
        const dateStr = dateObj.toISOString().split('T')[0];
        newRotaIdsByDate[dateStr] = rota._id;

        if (Array.isArray(rota.assignments)) {
          // Add date field to each assignment for easier filtering
          const assignmentsWithDate = rota.assignments.map((a: any) => ({
            ...a,
            date: dateStr
          }));
          allAssignments.push(...assignmentsWithDate);
        }
      }

      setRotaIdsByDate(newRotaIdsByDate);
      
      // If this is the initial load after generation, save it as the history's starting point
      if (rotaGenerated && allAssignments.length > 0 && 
          (assignmentHistory.length === 1 && assignmentHistory[0].length === 0 || 
           assignmentHistory.length === 0)) {
        console.log('[useEffect][populate rotaAssignments] Setting initial state for history');
        const initialState = JSON.parse(JSON.stringify(allAssignments));
        setAssignmentHistory([initialState]);
        setCurrentHistoryIndex(0);
      }
      
      setRotaAssignmentsLogged(allAssignments);
    }
  }, [allRotas, rotaGenerated, assignmentHistory]);

  // --- LOGGING: Selected Monday and Rendered Dates ---
  useEffect(() => {
    if (!selectedMonday) return;
    const dates = Array.from({ length: 5 }, (v: undefined, i: number) => {
      const d = new Date(selectedMonday);
      d.setDate(d.getDate() + i);
      return d.toISOString().split('T')[0];
    });
    console.log('[RotaView] selectedMonday:', selectedMonday, 'Rendered dates:', dates);
  }, [selectedMonday]);

  // Reset singlePharmacistDispensaryDays when selectedMonday changes
  useEffect(() => {
    setSinglePharmacistDispensaryDays([]);
  }, [selectedMonday]);

  // Modified regeneration function to accept state override
  // Handle publishing the rota
  const handlePublishRota = async () => {
    setIsPublishing(true);
    try {
      // Get the IDs for all rotas in the current week
      const rotaIds = Object.values(rotaIdsByDate);
      if (rotaIds.length === 0) {
        alert("No rotas to publish");
        return;
      }
      
      // Publish rotas one by one, passing the actual user name from state
      await Promise.all(rotaIds.map((rotaId) => {
        // Pass the user's name to be stored properly
        return publishRota({ 
          rotaId,
          userName: currentUser.name || currentUser.email || 'Unknown User'
        });
      }));
      
      setPublishSuccess(true);
      setTimeout(() => setPublishSuccess(false), 3000); // Clear success message after 3 seconds
    } catch (error) {
      console.error("Error publishing rota:", error);
      alert(`Error publishing rota: ${error}`);
    } finally {
      setIsPublishing(false);
    }
  };

  async function handleGenerateWeeklyRota(overrideSinglePharmacistDays?: string[], regenerateRota?: boolean) {
    // Prevent concurrent runs
    if (generatingWeekly) {
      console.warn('[handleGenerateWeeklyRota] Already generating, skipping concurrent call.');
      return;
    }
    if (!selectedMonday) return;

    setGeneratingWeekly(true); // Set generating flag BEFORE try block

    // Determine which state to use for the generation
    const daysToUse = overrideSinglePharmacistDays ?? singlePharmacistDispensaryDays;
    console.log('[handleGenerateWeeklyRota] Using singlePharmacistDays:', daysToUse);

    try {
      console.log(`[handleGenerateWeeklyRota] About to call Convex mutation with startDate: ${selectedMonday}, daysToUse: ${JSON.stringify(daysToUse)}`);
      await generateWeeklyRota({
        startDate: selectedMonday,
        pharmacistIds: selectedPharmacistIds,
        clinicIds: selectedClinicIds,
        pharmacistWorkingDays: pharmacistWorkingDays,
        singlePharmacistDispensaryDays: daysToUse, // Pass the determined state
        regenerateRota: regenerateRota, // Pass the regenerateRota flag
      });
      console.log(`[handleGenerateWeeklyRota] Convex mutation call finished for startDate: ${selectedMonday}`);
    } finally {
      setGeneratingWeekly(false);
      setRotaGenerated(true);
      console.log(`[handleGenerateWeeklyRota] finally block executed for startDate: ${selectedMonday}`);
    }
  }

  console.log('Rendering rotaAssignments', rotaAssignments);

  // Sort clinics by dayOfWeek and startTime for display
  const sortedSelectedClinics = clinics
    .filter((c: any) => selectedClinicIds.includes(c._id))
    .sort((a: any, b: any) => (a.dayOfWeek - b.dayOfWeek) || a.startTime.localeCompare(b.startTime));

  // Add helper to get the assignment index within the rota
  const getAssignmentIndexInRota = (assignment: any) => {
    const assignmentDate = new Date(assignment.date).toISOString().split('T')[0];
    const rotaId = rotaIdsByDate[assignmentDate];
    if (!rotaId) return { rotaId: null, indices: [] };

    const rota = allRotas.find((r: any) => r._id === rotaId);
    if (!rota) return { rotaId: null, indices: [] };

    // For dispensary assignments, find all slots for the same pharmacist in that time range
    if (assignment.location === "Dispensary") {
      const indices = rota.assignments
        .map((a: any, idx: number) => ({ ...a, idx }))
        .filter((a: any) => 
          a.location === "Dispensary" && 
          a.pharmacistId === assignment.pharmacistId
        )
        .map((a: any) => a.idx);
      return { rotaId, indices };
    }

    // For other assignments, just find the exact match
    const index = rota.assignments.findIndex((a: any) => 
      a.location === assignment.location && 
      a.start === assignment.start && 
      a.end === assignment.end
    );

    return { rotaId, indices: index !== -1 ? [index] : [] };
  };

  // Define the return type to include the exactTimeMatch property
  type AssignmentScopeResult = { 
    rotaId: Id<"rotas">; 
    indices: number[];
    exactTimeMatch?: boolean;
  };

  // Add helper to get assignments for scope
  const getAssignmentsForScope = (
  location: string, 
  date: string, 
  scope: "slot" | "day" | "week",
  startTime?: string,
  endTime?: string,
  currentPharmacistId?: Id<"pharmacists"> | null
): AssignmentScopeResult[] => {
  console.log(`[getAssignmentsForScope] Called with scope: ${scope}, location: ${location}, date: ${date}, startTime: ${startTime}, endTime: ${endTime}`);
  const results: AssignmentScopeResult[] = [];
  
  try {
    const isWard = location.includes("Ward") || location.includes("ITU") || location.includes("Emergency Assessment Unit");
    
    if (scope === "slot") {
      // For single slot, get the exact assignment
      const rotaId = rotaIdsByDate[date];
      if (!rotaId) {
        console.error(`[getAssignmentsForScope] No rota found for date: ${date}`);
        return results;
      }

      const rota = allRotas.find((r: any) => r._id === rotaId);
      if (!rota) {
        console.error(`[getAssignmentsForScope] Rota not found in allRotas for ID: ${rotaId}`);
        return results;
      }

      // Ensure startTime and endTime are provided for slot scope
      if (!startTime || !endTime) {
        console.error("[getAssignmentsForScope] StartTime or EndTime missing for 'slot' scope.");
        return results;
      }
      
      // Find exact time slot matches for this location
      const exactMatches = rota.assignments
        .map((a: any, idx: number) => ({ ...a, idx }))
        .filter((a: any) => 
          a.location === location && 
          a.startTime === startTime && 
          a.endTime === endTime
        )
        .map((a: any) => a.idx);
      
      console.log(`[getAssignmentsForScope] Found ${exactMatches.length} exact matches for ${location} at ${startTime}-${endTime}`);
      
      // If we found exact time-specific assignments for this slot, use those
      if (exactMatches.length > 0) {
        console.log(`[getAssignmentsForScope] Found exact match assignments for slot: ${exactMatches.join(', ')}`);
        return [{
          rotaId,
          indices: exactMatches,
          exactTimeMatch: true
        }];
      }
      
      // If we have a specific pharmacist ID, look for overlapping assignments for that pharmacist
      if (currentPharmacistId) {
        const overlappingAssignments = rota.assignments
          .map((a: any, idx: number) => ({ ...a, idx, pharmacistId: a.pharmacistId }))
          .filter((a: any) => 
            a.location === location && 
            a.pharmacistId === currentPharmacistId &&
            a.startTime <= startTime && 
            a.endTime >= endTime
          );
          
        if (overlappingAssignments.length > 0) {
          console.log(`[getAssignmentsForScope] Found ${overlappingAssignments.length} overlapping assignments with specific pharmacist`);
          return [{
            rotaId,
            indices: [overlappingAssignments[0].idx],
            exactTimeMatch: false
          }];
        }
      }
      
      // If no exact match or pharmacist-specific assignment, try for any overlapping assignment
      const overlappingAssignments = rota.assignments
        .map((a: any, idx: number) => ({ ...a, idx }))
        .filter((a: any) => 
          a.location === location && 
          a.startTime <= startTime && 
          a.endTime >= endTime
        );
        
      if (overlappingAssignments.length > 0) {
        console.log(`[getAssignmentsForScope] Found ${overlappingAssignments.length} overlapping assignments`);
        return [{
          rotaId,
          indices: [overlappingAssignments[0].idx],
          exactTimeMatch: false
        }];
      }
      
      // No assignments found at all, will create a new one
      console.log(`[getAssignmentsForScope] No assignments found for this slot. Will create new one.`);
      return [];
      
    } else if (scope === "day") {
      // For day, get all assignments for this location on this date
      const rotaId = rotaIdsByDate[date];
      if (!rotaId) {
        console.error(`[getAssignmentsForScope] No rota found for date: ${date}`);
        return results;
      }

      const rota = allRotas.find((r: any) => r._id === rotaId);
      if (!rota) {
        console.error(`[getAssignmentsForScope] Rota not found in allRotas for ID: ${rotaId}`);
        return results;
      }
      
      // Get all assignments for this location
      const allAssignments = rota.assignments
        .map((a: any, idx: number) => ({ ...a, idx, pharmacistId: a.pharmacistId }))
        .filter((a: any) => a.location === location);
        
      console.log(`[getAssignmentsForScope] Found ${allAssignments.length} assignments for day scope`);
      
      if (allAssignments.length > 0) {
        // If we have a currentPharmacistId, find only assignments with that pharmacist
        if (currentPharmacistId) {
          console.log(`[getAssignmentsForScope] Looking for day assignments with pharmacistId: ${currentPharmacistId}`);
          
          // Find assignments with this specific pharmacist
          const specificAssignments = allAssignments.filter(a => 
            a.pharmacistId === currentPharmacistId
          );
          
          if (specificAssignments.length > 0) {
            const specificIndices = specificAssignments.map(a => a.idx);
            console.log(`[getAssignmentsForScope] Found ${specificIndices.length} specific assignments for pharmacist ${currentPharmacistId}: ${specificIndices.join(', ')}`);
            results.push({ rotaId, indices: specificIndices });
            return results;
          } else {
            console.log(`[getAssignmentsForScope] No specific assignments found for pharmacist ${currentPharmacistId}`);
            return [];
          }
        } else {
          // If no specific pharmacist ID provided, return all assignments
          const allIndices = allAssignments.map(a => a.idx);
          console.log(`[getAssignmentsForScope] No specific pharmacist ID provided, returning all ${allIndices.length} assignments`);
          results.push({ rotaId, indices: allIndices });
        }
      }
      
    } else { // week scope
      // For week, get all assignments for this location across all rotas
      console.log(`[getAssignmentsForScope] Scope: week, Checking all rotas for location: ${location}`);
      
      // Iterate through all days in the week
      Object.entries(rotaIdsByDate).forEach(([currentDate, rotaId]) => {
        const rota = allRotas.find((r: any) => r._id === rotaId);
        if (!rota) {
          console.error(`[getAssignmentsForScope] Rota not found in allRotas for ID: ${rotaId} on date ${currentDate}`);
          return;
        }
        
        // Get all assignments for this location
        const allAssignments = rota.assignments
          .map((a: any, idx: number) => ({ ...a, idx, pharmacistId: a.pharmacistId }))
          .filter((a: any) => a.location === location);
          
        console.log(`[getAssignmentsForScope] Found ${allAssignments.length} assignments for week scope on ${currentDate}`);
        
        if (allAssignments.length > 0) {
          // If we have a currentPharmacistId, find only assignments with that pharmacist
          if (currentPharmacistId) {
            console.log(`[getAssignmentsForScope] Looking for week assignments with pharmacistId: ${currentPharmacistId}`);
            
            // Find assignments with this specific pharmacist
            const specificAssignments = allAssignments.filter(a => 
              a.pharmacistId === currentPharmacistId
            );
            
            if (specificAssignments.length > 0) {
              const specificIndices = specificAssignments.map(a => a.idx);
              console.log(`[getAssignmentsForScope] Found ${specificIndices.length} specific assignments for pharmacist ${currentPharmacistId} on ${currentDate}: ${specificIndices.join(', ')}`);
              results.push({ rotaId, indices: specificIndices });
            } else {
              console.log(`[getAssignmentsForScope] No specific assignments found for pharmacist ${currentPharmacistId} on ${currentDate}`);
            }
          } else {
            // If no specific pharmacist ID provided, return all assignments
            const allIndices = allAssignments.map(a => a.idx);
            console.log(`[getAssignmentsForScope] No specific pharmacist ID provided, returning all ${allIndices.length} assignments for ${currentDate}`);
            results.push({ rotaId, indices: allIndices });
          }
        } else {
          console.log(`[getAssignmentsForScope] No assignments found for week scope on ${currentDate}`);
        }
      });
    }

    console.log('[getAssignmentsForScope] Returning results:', JSON.stringify(results));
    return results;
  } catch (error) {
    console.error(`[getAssignmentsForScope] Error:`, error);
    return results;
  }
};

  // Add helper to determine the assignments to display in a specific cell (returns array to handle multiple pharmacists)
const getAssignmentsForCell = (
  location: string,
  date: string,
  slotStartTime: string,
  slotEndTime: string,
  allAssignmentsForDate: any[] // Pass the relevant rota.assignments array for the specific date
): any[] => {
  // Determine if it's a ward
  const isWard = location.includes("Ward") || location.includes("ITU") || location.includes("Emergency Assessment Unit");
  const assignments = [];

  // 1. Check for exact slot matches
  const specificAssignments = allAssignmentsForDate.filter(a =>
    a.location === location &&
    a.startTime === slotStartTime &&
    a.endTime === slotEndTime
  );

  if (specificAssignments.length > 0) {
    return specificAssignments;
  }

  // 2. If it's a ward and no specific assignments found, check for full-day assignments
  if (isWard) {
    const fullDayAssignments = allAssignmentsForDate.filter(a =>
      a.location === location &&
      a.startTime === '00:00' &&
      a.endTime === '23:59'
    );
    if (fullDayAssignments.length > 0) {
      return fullDayAssignments;
    }
  }

  // 3. No assignments found
  return [];
};

// Backward compatibility function - returns the first assignment or null for old code
const getAssignmentForCell = (
  location: string,
  date: string,
  slotStartTime: string,
  slotEndTime: string,
  allAssignmentsForDate: any[]
): any | null => {
  const assignments = getAssignmentsForCell(location, date, slotStartTime, slotEndTime, allAssignmentsForDate);
  return assignments.length > 0 ? assignments[0] : null;
};  

  // Drag and drop functions for swapping pharmacists
  const handleDragStart = (
    event: React.DragEvent<HTMLSpanElement>, 
    pharmacistId: Id<"pharmacists">, 
    assignment: any,
    location: string,
    date: string,
    slotStartTime: string,
    slotEndTime: string
  ) => {
    if (isViewOnly) return; // Prevent drag in view-only mode
    
    // Set dragSource with the current cell's data
    setDragSource({
      pharmacistId,
      assignment,
      location,
      date,
      startTime: slotStartTime,
      endTime: slotEndTime
    });
    
    // Set drag data
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', pharmacistId as string);
    
    // Add visual feedback for source element
  
  event.preventDefault();
    assignment: any | null, 
    location: string, 
    date: string, 
    slotStartTime: string, 
    slotEndTime: string
  ) => {
    if (isViewOnly || !dragSource || !pharmacistId) return; // Don't allow dropping in view-only mode or if no drag started or no pharmacist to swap with
    
    // Don't allow dropping on the same cell that started the drag
    if (dragSource.pharmacistId === pharmacistId && 
        dragSource.date === date && 
        dragSource.location === location &&
        dragSource.startTime === slotStartTime &&
        dragSource.endTime === slotEndTime) {
      return;
    }
    
    // Allow dropping by preventing default
    event.preventDefault();
    
    // Update the dragTarget state
    setDragTarget({
      pharmacistId,
      assignment,
      location,
      date,
      startTime: slotStartTime,
      endTime: slotEndTime
    });
    
    // Add visual feedback
    const element = event.currentTarget;
    element.classList.add('bg-blue-100');
  };
  
  const handleDragLeave = (event: React.DragEvent<HTMLTableDataCellElement>) => {
    // Remove visual feedback
    event.currentTarget.classList.remove('bg-blue-100');
  };
  
  const handleDrop = (event: React.DragEvent<HTMLTableDataCellElement>) => {
    if (isViewOnly || !dragSource || !dragTarget) return;
    
    event.preventDefault();
    
    // Remove visual feedback
    event.currentTarget.classList.remove('bg-blue-100');
    
    // Remove source highlight
    const cells = document.querySelectorAll('.rota-drag-cell');
    cells.forEach(cell => {
      cell.classList.remove('bg-yellow-100');
      cell.classList.remove('bg-blue-100');
    });
    
    // Check if we're trying to swap with the same cell
    if (dragSource.date === dragTarget.date && 
        dragSource.location === dragTarget.location &&
        dragSource.startTime === dragTarget.startTime &&
        dragSource.endTime === dragTarget.endTime) {
      setDragSource(null);
      setDragTarget(null);
      return;
    }
    
    // Check if the target has a pharmacist (we only swap with cells that have pharmacists)
    if (!dragTarget.pharmacistId) {
      console.log('Target has no pharmacist, cannot swap');
      setDragSource(null);
      setDragTarget(null);
      return;
    }
    
    // Call the swap function
    swapPharmacists();
    );

    const otherPharmacistIds = otherAssignments.map((a: any) => a.pharmacistId);
    
    console.log(`[handleCellClick] Selected pharmacist ${currentPharmacistId} at index ${clickedAssignmentIndex}`);
    console.log(`[handleCellClick] Other pharmacists in this cell: ${otherPharmacistIds.length > 0 ? otherPharmacistIds.join(', ') : 'none'}`);

    // Store both the selected pharmacist and other pharmacists in the cell
    setSelectedCell({ 
      rotaId,
      assignmentIndices: [clickedAssignmentIndex],
      currentPharmacistId,
      location: assignment.location,
      date: assignmentDate,
      startTime: cellStartTime,
      endTime: cellEndTime,
      otherPharmacistIds // Keep track of other pharmacists in the same cell
    });
    setShowPharmacistSelection(true);
  };

  const handlePharmacistSelect = async (pharmacistId: Id<"pharmacists">, scope: "slot" | "day" | "week") => {
  if (!selectedCell) {
    console.error("[handlePharmacistSelect] No cell selected");
    return;
  }
  
  const newAssignment = selectedCell.newAssignment;
  console.log(`[handlePharmacistSelect] Started. Scope: ${scope}, PharmacistID: ${pharmacistId}, Location: ${selectedCell.location}, Date: ${selectedCell.date}, Start: ${selectedCell.startTime}, End: ${selectedCell.endTime}`);

  // Log information about other pharmacists in the cell
  if (selectedCell.otherPharmacistIds && selectedCell.otherPharmacistIds.length > 0) {
    console.log(`[handlePharmacistSelect] Will preserve ${selectedCell.otherPharmacistIds.length} other pharmacist(s) in this cell:`, 
      selectedCell.otherPharmacistIds.map(id => ({ id, name: getPharmacistName(id) }))
    );
  }

  try {
    // Determine if this is a ward (which uses full-day assignments)
    const isWard = selectedCell.location.includes("Ward") || 
                   selectedCell.location.includes("ITU") || 
                   selectedCell.location.includes("Emergency Assessment Unit");

    if (newAssignment) {
      console.log("[handlePharmacistSelect] Handling new assignment creation.");
      // For new assignments, create a new slot
      await updateAssignment({
        rotaId: selectedCell.rotaId,
        assignmentIndex: -1,
        pharmacistId,
        newAssignment
      });
      console.log("[handlePharmacistSelect] Initial new assignment created.");

      // If scope is day or week, create additional slots
      if (scope !== "slot") {
        console.log(`[handlePharmacistSelect] Creating additional slots for scope: ${scope}`);
        const timeSlots = TIME_SLOTS.map(slot => ({
          startTime: slot.start,
          endTime: slot.end
        })).filter(slot => 
          // Don't duplicate the slot we just created
          slot.startTime !== newAssignment.startTime ||
          slot.endTime !== newAssignment.endTime
        );

        // For week scope, get all dates
        const dates = scope === "week" 
          ? Object.keys(rotaIdsByDate)
          : [selectedCell.date];

        // Create assignments for each time slot and date
        for (const date of dates) {
          const rotaId = rotaIdsByDate[date];
          if (!rotaId) {
            console.warn(`[handlePharmacistSelect] No rota found for date: ${date}`);
            continue;
          }

          for (const slot of timeSlots) {
            await updateAssignment({
              rotaId,
              assignmentIndex: -1,
              pharmacistId,
              newAssignment: {
                location: newAssignment.location,
                type: newAssignment.type,
                startTime: slot.startTime,
                endTime: slot.endTime
              }
            });
          }
        }
        console.log(`[handlePharmacistSelect] Finished creating additional slots for scope: ${scope}`);
      }
    } else {
      console.log("[handlePharmacistSelect] Handling existing assignment update.");
      
      if (scope === "slot") {
        console.log("[handlePharmacistSelect] Handling slot scope");
        
        if (!selectedCell.startTime || !selectedCell.endTime) {
          console.error("[handlePharmacistSelect] Missing startTime or endTime for slot scope");
          return;
        }
        
        // Get any existing assignments for this slot - same handling for all wards
        const assignmentsToUpdate = getAssignmentsForScope(
          selectedCell.location, 
          selectedCell.date, 
          "slot",
          selectedCell.startTime,
          selectedCell.endTime,
          selectedCell.currentPharmacistId
        );
        
        if (assignmentsToUpdate.length > 0 && assignmentsToUpdate[0].indices.length > 0) {
          // We found an existing assignment for this slot - update it
          const { rotaId, indices } = assignmentsToUpdate[0];
          console.log(`[handlePharmacistSelect] Updating existing assignment at index ${indices[0]}`);
          
          // 1. Update the specific clicked assignment
          await updateAssignment({
            rotaId,
            assignmentIndex: indices[0],
            pharmacistId,
            newAssignment: {
              location: selectedCell.location,
              type: "ward",
              startTime: selectedCell.startTime,
              endTime: selectedCell.endTime
            }
          });
          
          // 2. If there were other pharmacists in this cell that we need to preserve,
          // make sure they still have assignments
          if (selectedCell.otherPharmacistIds && selectedCell.otherPharmacistIds.length > 0) {
            console.log(`[handlePharmacistSelect] Preserving ${selectedCell.otherPharmacistIds.length} other pharmacist assignments in this cell`);
            
            // Check if each pharmacist already has an assignment for this slot
            for (const otherId of selectedCell.otherPharmacistIds) {
              const hasExistingAssignment = rotaAssignments.some(a => 
                a.pharmacistId === otherId &&
                a.location === selectedCell.location &&
                a.date === selectedCell.date &&
                a.startTime === selectedCell.startTime &&
                a.endTime === selectedCell.endTime
              );
              
              // Only create a new assignment if one doesn't already exist
              if (!hasExistingAssignment) {
                console.log(`[handlePharmacistSelect] Creating missing assignment for ${getPharmacistName(otherId)}`);
                
                await updateAssignment({
                  rotaId,
                  assignmentIndex: -1, // Create new
                  pharmacistId: otherId,
                  newAssignment: {
                    location: selectedCell.location,
                    type: "ward",
                    startTime: selectedCell.startTime,
                    endTime: selectedCell.endTime
                  }
                });
              }
            }
          }
        } else {
          // No existing assignment found - create a new one
          console.log("[handlePharmacistSelect] No existing assignment found. Creating new one.");
          
          // 1. Create assignment for the selected pharmacist
          await updateAssignment({
            rotaId: selectedCell.rotaId,
            assignmentIndex: -1, // Create new
            pharmacistId,
            newAssignment: {
              location: selectedCell.location,
              type: "ward",
              startTime: selectedCell.startTime,
              endTime: selectedCell.endTime
            }
          });
          
          // 2. Ensure all other pharmacists have assignments in this cell
          if (selectedCell.otherPharmacistIds && selectedCell.otherPharmacistIds.length > 0) {
            console.log(`[handlePharmacistSelect] Preserving ${selectedCell.otherPharmacistIds.length} other pharmacist assignments in this cell`);
            
            for (const otherId of selectedCell.otherPharmacistIds) {
              console.log(`[handlePharmacistSelect] Creating assignment for ${getPharmacistName(otherId)}`);
              
              await updateAssignment({
                rotaId: selectedCell.rotaId,
                assignmentIndex: -1, // Create new
                pharmacistId: otherId,
                newAssignment: {
                  location: selectedCell.location,
                  type: "ward",
                  startTime: selectedCell.startTime,
                  endTime: selectedCell.endTime
                }
              });
            }
          }
        }
      } else {
        // For day or week scope
        console.log(`[handlePharmacistSelect] Handling ${scope} scope for ward`);
        
        const assignmentsToUpdate = getAssignmentsForScope(
          selectedCell.location, 
          selectedCell.date, 
          scope,
          selectedCell.startTime,
          selectedCell.endTime,
          selectedCell.currentPharmacistId
        );
        
        console.log(`[handlePharmacistSelect] Found ${assignmentsToUpdate.length} assignments to update`);
        
        if (assignmentsToUpdate.length === 0) {
          console.warn("[handlePharmacistSelect] No assignments found to update for the selected scope and details.");
          return;
        }
        
        // Update each assignment
        for (const { rotaId, indices } of assignmentsToUpdate) {
          console.log(`[handlePharmacistSelect] Updating ${indices.length} assignments for rota ${rotaId}`);
          for (const idx of indices) {
            await updateAssignment({
              rotaId,
              assignmentIndex: idx,
              pharmacistId
            });
          }
        }
      }
      console.log("[handlePharmacistSelect] Finished updating assignments.");
    }

    // Refresh the local state to show the updated assignments
    console.log("[handlePharmacistSelect] Refreshing local rotaAssignments state.");
    
    // Refresh the local state with the latest data from allRotas
    // This is more reliable than trying to manually track which assignments were updated
    const refreshedAssignments = allRotas.flatMap((r: any) => 
      r.assignments.map((a: any) => ({ ...a, date: r.date }))
    );
    setRotaAssignments(refreshedAssignments);
    console.log(`[handlePharmacistSelect] Local state refreshed with ${refreshedAssignments.length} assignments.`);
  } catch (error) {
    console.error('[handlePharmacistSelect] Failed to update assignment:', error);
  } finally {
    // Close the modal and clear selection
    setShowPharmacistSelection(false);
    setSelectedCell(null);
    console.log("[handlePharmacistSelect] Modal closed and selection cleared.");
  }
};

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex gap-4 mt-6">
        <div>
          <label className="block font-medium mb-1">Select Monday (week start)</label>
          <input
            type="date"
            className="border rounded px-2 py-1"
            value={selectedMonday}
            onChange={e => setSelectedMonday(e.target.value)}
            min="2024-01-01"
            step="7"
          />
        </div>
        <button
          className="bg-blue-600 text-white px-3 py-2 rounded mt-6 disabled:opacity-50"
          disabled={!selectedMonday || generatingWeekly}
          onClick={() => {
            setShowClinicSelection(true);
            setRotaGenerated(false);
          }}
        >
          Create Rota
        </button>
      </div>
      {showClinicSelection && !rotaGenerated && (
        <div className="mb-4">
          <h3 className="font-medium mb-2">Select Clinics to Include in Rota</h3>
          <div className="flex flex-wrap gap-4">
            {clinics.slice().sort((a: any, b: any) => (a.dayOfWeek - b.dayOfWeek) || a.startTime.localeCompare(b.startTime)).map((clinic: any) => (
              <label key={clinic._id} className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={selectedClinicIds.includes(clinic._id)}
                  onChange={e => {
                    setSelectedClinicIds((ids: Array<Id<"clinics">>) =>
                      e.target.checked
                        ? [...ids, clinic._id]
                        : ids.filter(id => id !== clinic._id)
                    );
                  }}
                />
                <span>{clinic.name} ({CLINIC_DAY_LABELS[clinic.dayOfWeek-1]} {clinic.startTime}-{clinic.endTime})</span>
              </label>
            ))}
          </div>
          <button
            className="mt-4 bg-green-600 text-white py-2 px-4 rounded hover:bg-green-700 disabled:opacity-50"
            disabled={selectedClinicIds.length === 0}
            onClick={() => {
              setShowClinicSelection(false);
              setShowPharmacistSelection(true);
            }}
          >
            Confirm Clinics
          </button>
        </div>
      )}
      {showPharmacistSelection && !rotaGenerated && (
        <div className="mb-4">
          <h3 className="font-medium mb-2">Select Pharmacists and Working Days</h3>
          <div className="flex flex-col gap-2">
            {[...pharmacists.filter((p: any) => p.isDefaultPharmacist),
              ...pharmacists.filter((p: any) =>
                !p.isDefaultPharmacist && selectedPharmacistIds.includes(p._id)
              ),
            ]
              .sort((a: any, b: any) => a.name.localeCompare(b.name))
              .map((pharmacist: any) => (
                <div key={pharmacist._id} className="border rounded p-2 flex flex-col md:flex-row items-start md:items-center gap-3">
                  <div className="flex items-center gap-2">
                    <input
                      type="checkbox"
                      checked={selectedPharmacistIds.includes(pharmacist._id)}
                      onChange={e => {
                        setSelectedPharmacistIds((ids: Array<Id<"pharmacists">>) => {
                          const checked = e.target.checked;
                          if (checked && !ids.includes(pharmacist._id)) {
                            if (!pharmacistWorkingDays[pharmacist._id]) {
                              const newObj = { ...pharmacistWorkingDays };
                              newObj[pharmacist._id] = Array.isArray(pharmacist.workingDays) ? pharmacist.workingDays : CLINIC_DAY_LABELS;
                              setPharmacistWorkingDaysLogged(newObj);
                            }
                            return [...ids, pharmacist._id];
                          }
                          if (!checked) {
                            const newObj = { ...pharmacistWorkingDays };
                            delete newObj[pharmacist._id];
                            setPharmacistWorkingDaysLogged(newObj);
                            return ids.filter(id => id !== pharmacist._id);
                          }
                          return ids;
                        });
                      }}
                    />
                    <span className="font-medium">{pharmacist.name}</span>
                    {pharmacist.isDefaultPharmacist && (
                      <span className="ml-2 px-2 py-0.5 text-xs bg-blue-100 text-blue-700 rounded">Default</span>
                    )}
                  </div>
                  {selectedPharmacistIds.includes(pharmacist._id) && (
                    <div className="flex flex-wrap gap-4 mt-2 md:mt-0 items-center">
                      <div className="flex gap-2 items-center">
                        <span className="font-semibold text-xs whitespace-nowrap mr-1">Working Days:</span>
                        {CLINIC_DAY_LABELS.map((day: string) => (
                          <label key={day} className="flex items-center gap-1">
                            <input
                              type="checkbox"
                              checked={pharmacistWorkingDays[pharmacist._id]?.includes(day) || false}
                              onChange={e => {
                                handleSetPharmacistWorkingDays(pharmacist._id, day, e.target.checked);
                              }}
                            />
                            <span className="text-xs">{day}</span>
                          </label>
                        ))}
                      </div>
                      <div className="flex items-center gap-2 ml-4">
                        <span className="font-semibold text-xs whitespace-nowrap">Protected Rota Time:</span>
                        <ul className="flex gap-2 mb-0">
                          {getAllUnavailableRules(pharmacist).map((rule, idx) => (
                            <li key={idx} className="flex items-center gap-1 text-xs bg-red-50 rounded px-1">
                              <span>{rule.dayOfWeek} {rule.startTime}-{rule.endTime}</span>
                              <button
                                type="button"
                                className="text-red-500 text-xs ml-1"
                                onClick={() => {
                                  if (idx < (pharmacist.notAvailableRules?.length || 0)) {
                                    const updated = [...(pharmacist.notAvailableRules || [])];
                                    updated.splice(idx, 1);
                                    setRotaUnavailableRules(prev => ({
                                      ...prev,
                                      [pharmacist._id]: [
                                        ...((prev[pharmacist._id] || [])),
                                        ...updated.filter((_, i) => i !== idx)
                                      ]
                                    }));
                                    pharmacist.notAvailableRules.splice(idx, 1);
                                  } else {
                                    removeRotaUnavailableRule(pharmacist._id, idx - (pharmacist.notAvailableRules?.length || 0));
                                  }
                                }}
                              ></button>
                            </li>
                          ))}
                        </ul>
                        <select className="border rounded text-xs" id={`unavail-day-${pharmacist._id}`}>{CLINIC_DAY_LABELS.map(day => <option key={day} value={day}>{day}</option>)}</select>
                        <input className="border rounded text-xs w-20" id={`unavail-start-${pharmacist._id}`} type="time" defaultValue="09:00" />
                        <input className="border rounded text-xs w-20" id={`unavail-end-${pharmacist._id}`} type="time" defaultValue="17:00" />
                        <button type="button" className="text-blue-600 text-xs border px-1 rounded" onClick={() => {
                          const day = (document.getElementById(`unavail-day-${pharmacist._id}`) as HTMLSelectElement).value;
                          const start = (document.getElementById(`unavail-start-${pharmacist._id}`) as HTMLInputElement).value;
                          const end = (document.getElementById(`unavail-end-${pharmacist._id}`) as HTMLInputElement).value;
                          addRotaUnavailableRule(pharmacist._id, { dayOfWeek: day, startTime: start, endTime: end });
                        }}>Add</button>
                      </div>
                    </div>
                  )}
                </div>
              ))}
            {/* Pharmacist search bar for non-defaults */}
            <div className="mb-3 flex items-center gap-2">
              <input
                type="text"
                placeholder="Search pharmacists..."
                className="border rounded px-2 py-1 w-64"
                value={pharmacistSearch}
                onChange={e => setPharmacistSearch(e.target.value)}
              />
            </div>
            {/* Non-default pharmacists, always shown and filtered by search */}
            {(
              <div className="border rounded p-4 mb-4 bg-gray-50">
                <h4 className="font-medium mb-2">Search Results</h4>
                {[...pharmacists]
                  .filter((p: any) => 
                    // Only show non-default pharmacists that aren't already selected
                    !p.isDefaultPharmacist &&
                    !selectedPharmacistIds.includes(p._id) &&
                    // Filter by search text if provided
                    (pharmacistSearch === '' || p.name.toLowerCase().includes(pharmacistSearch.toLowerCase()))
                  )
                  .sort((a: any, b: any) => a.name.localeCompare(b.name))
                  .map((pharmacist: any) => {
                    // Prepare temporary working days state for this pharmacist
                    const tempWorkingDays = pharmacistWorkingDays[pharmacist._id] || 
                      (Array.isArray(pharmacist.workingDays) ? pharmacist.workingDays : CLINIC_DAY_LABELS);
                    
                    return (
                      <div key={pharmacist._id} className="border rounded p-2 mb-2 bg-white">
                        <div className="flex items-center gap-2 mb-2">
                          <span className="font-medium">{pharmacist.name}</span>
                          <span className="text-sm text-gray-500">Band {pharmacist.band}</span>
                          {pharmacist.primaryDirectorate && (
                            <span className="text-sm bg-gray-100 px-1 py-0.5 rounded">
                              {pharmacist.primaryDirectorate}
                            </span>
                          )}
                        </div>
                        <div className="flex flex-wrap gap-2 items-center mb-2">
                          <span className="text-sm font-medium">Available on:</span>
                          {CLINIC_DAY_LABELS.map((day: string) => {
                            const isSelected = tempWorkingDays.includes(day);
                            return (
                              <button
                                key={day}
                                type="button"
                                className={`text-xs px-2 py-1 rounded-full transition-colors ${
                                  isSelected 
                                    ? "bg-green-100 text-green-800 border border-green-300" 
                                    : "bg-gray-100 text-gray-600 border border-gray-200 hover:bg-gray-200"
                                }`}
                                onClick={() => {
                                  // Create a temporary working days state for this pharmacist
                                  const newObj = { ...pharmacistWorkingDays };
                                  if (!newObj[pharmacist._id]) {
                                    newObj[pharmacist._id] = [...tempWorkingDays];
                                  }
                                  
                                  if (isSelected) {
                                    // Remove day if already selected
                                    newObj[pharmacist._id] = newObj[pharmacist._id].filter(d => d !== day);
                                  } else {
                                    // Add day if not selected
                                    newObj[pharmacist._id] = [...newObj[pharmacist._id], day];
                                  }
                                  
                                  setPharmacistWorkingDaysLogged(newObj);
                                }}
                                disabled={isViewOnly}
                              >
                                {day}
                              </button>
                            );
                          })}
                        </div>
                        <div className="flex justify-end">
                          <button
                            type="button"
                            className="bg-blue-600 text-white text-sm px-3 py-1 rounded hover:bg-blue-700"
                            onClick={() => {
                              setSelectedPharmacistIds(ids => [...ids, pharmacist._id]);
                              setPharmacistSearch(''); // Clear search after adding
                            }}
                            disabled={isViewOnly}
                          >
                            Add to Rota
                          </button>
                        </div>
                      </div>
                    );
                  })}
                {[...pharmacists]
                  .filter((p: any) => 
                    !p.isDefaultPharmacist &&
                    !selectedPharmacistIds.includes(p._id) &&
                    (pharmacistSearch === '' || p.name.toLowerCase().includes(pharmacistSearch.toLowerCase()))
                  ).length === 0 && (
                  <div className="text-gray-500 italic">No non-default pharmacists available</div>
                )}
              </div>
            )}
          </div>
          <button
            className="mt-4 bg-green-600 text-white py-2 px-4 rounded hover:bg-green-700 disabled:opacity-50"
            disabled={selectedPharmacistIds.length === 0 || isViewOnly}
            onClick={() => {
              setShowPharmacistSelection(false);
              handleGenerateWeeklyRota();
            }}
          >
            Confirm Pharmacists
          </button>
        </div>
      )}
      {rotaGenerated && (
        <div className="mt-10">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-xl font-bold">Weekly Rota Table</h3>
            <div className="flex items-center space-x-2">
              {publishSuccess && (
                <span className="text-green-600 text-sm bg-green-100 px-2 py-1 rounded">
                  Rota published successfully!
                </span>
              )}
              <div className="flex space-x-2">
                <button
                  className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 disabled:opacity-50 flex items-center"
                  onClick={handleUndo}
                  disabled={currentHistoryIndex === 0 || isViewOnly}
                  title="Undo the last change"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z" clipRule="evenodd" />
                  </svg>
                  Undo
                </button>
                
                <button
                  className="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 disabled:opacity-50 flex items-center"
                  onClick={handleReset}
                  disabled={currentHistoryIndex === 0 || isViewOnly}
                  title="Reset to original rota"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clipRule="evenodd" />
                  </svg>
                  Reset
                </button>
                
                <button
                  className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 disabled:opacity-50 flex items-center"
                  onClick={handlePublishRota}
                  disabled={isPublishing || isViewOnly}
                >
                  {isPublishing ? (
                    <>
                      <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                      </svg>
                      Publishing...
                    </>
                  ) : "Publish Rota"}
                </button>
              </div>
            </div>
          </div>
          {/* Dispensary Mode Toggles */}
          <div className="mb-4">
            {[0,1,2,3,4].map((dayOffset: number) => {
              const date = new Date(selectedMonday);
              date.setDate(date.getDate() + dayOffset);
              const isoDate = date.toISOString().split('T')[0];
              
              // Check if this day has a dispensary pharmacist
              const hasDispensaryPharmacist = pharmacists.some(p => {
                return p.band === "Dispensary Pharmacist" && 
                       selectedPharmacistIds.includes(p._id) && // Only consider selected pharmacists
                       // Check if they work on this day (either no working days specified or this day is included)
                       (pharmacistWorkingDays[p._id]?.includes(DAYS[date.getDay()]) || 
                          (!pharmacistWorkingDays[p._id] && p.workingDays?.includes(DAYS[date.getDay()]))) &&
                       // And they don't have unavailable rules that conflict with the whole day
                       (!getAllUnavailableRules(p).some(rule => 
                          rule.dayOfWeek === DAYS[date.getDay()] &&
                          !(rule.endTime <= "09:00" || rule.startTime >= "17:00")
                       ));
              });
              
              // Only show toggle for days without dispensary pharmacist
              if (!hasDispensaryPharmacist) {
                return (
                  <div key={isoDate} className="flex items-center gap-2 mb-2">
                    <label className="flex items-center cursor-pointer">
                      <div className="mr-2 text-sm font-medium">
                        {DAYS[date.getDay()]} ({date.toLocaleDateString()}): 
                      </div>
                      <div className="relative">
                        <input
                          type="checkbox"
                          className="sr-only"
                          checked={singlePharmacistDispensaryDays.includes(isoDate)}
                          onChange={e => {
                            const isChecked = e.target.checked;
                            let nextState: string[];
                            // Calculate the next state *before* setting it
                            if (isChecked) {
                               nextState = [...singlePharmacistDispensaryDays, isoDate];
                            } else {
                               nextState = singlePharmacistDispensaryDays.filter(d => d !== isoDate);
                            }
                            // Set the state
                            setSinglePharmacistDispensaryDays(nextState);
                            // Immediately call regeneration with the calculated next state
                            handleGenerateWeeklyRota(nextState, true);
                          }}
                        />
                        <div className={`w-10 h-5 bg-gray-200 rounded-full shadow-inner transition-colors ${singlePharmacistDispensaryDays.includes(isoDate) ? 'bg-blue-500' : ''}`}></div>
                        <div className={`absolute w-4 h-4 bg-white rounded-full shadow top-0.5 left-0.5 transition ${singlePharmacistDispensaryDays.includes(isoDate) ? 'transform translate-x-5' : ''}`}></div>
                      </div>
                      <div className="ml-2 text-sm text-gray-700">
                        {singlePharmacistDispensaryDays.includes(isoDate) 
                          ? "Single pharmacist all day" 
                          : "Multiple pharmacists (2-hour slots)"}
                      </div>
                    </label>
                  </div>
                );
              }
              return null;
            })}
          </div>
          
          <div className="overflow-x-auto w-full max-w-full">
            <table className="border text-xs md:text-sm table-fixed w-full">
              <colgroup>
                <col style={{ width: '120px' }} />
                <col style={{ width: '120px' }} />
                {[...Array(5 * TIME_SLOTS.length)].map((_, idx) => (
                  <col key={idx} style={{ width: '70px' }} />
                ))}
              </colgroup>
              <thead>
                <tr>
                  <th className="border p-2 bg-gray-100 sticky left-0 z-10 border-b border-gray-200" style={{ borderBottomWidth: 1 }}>Directorate</th>
                  <th className="border p-2 bg-gray-100 sticky left-0 z-10 border-b border-gray-200" style={{ borderBottomWidth: 1 }}>Ward</th>
                  {[0,1,2,3,4].map((dayOffset: number) => {
                    const date = new Date(selectedMonday);
                    date.setDate(date.getDate() + dayOffset);
                    return (
                      <th key={dayOffset} colSpan={TIME_SLOTS.length} className="border p-2 bg-gray-100 text-xs border-r-4 border-gray-400 border-b border-gray-200" style={{ borderBottomWidth: 1 }}>
                        {DAYS[date.getDay()]}<br/>{date.toLocaleDateString()}
                      </th>
                    );
                  })}
                </tr>
                <tr>
                  <th className="border p-2 sticky left-0 bg-white z-10 border-b border-gray-200" colSpan={2} style={{ borderBottomWidth: 1 }}></th>
                  {[...Array(5)].flatMap((_, dayIdx: number) =>
                    TIME_SLOTS.map((slot: { start: string; end: string }, slotIdx: number) => (
                      <th key={dayIdx + '-' + slot.start + '-' + slot.end}
                        className={`border p-2 bg-blue-50 text-xs${slotIdx === TIME_SLOTS.length - 1 ? ' border-r-4 border-gray-400' : ''}`}
                        style={{ borderBottom: '1px solid #e5e7eb', borderRight: slotIdx === TIME_SLOTS.length - 1 ? '4px solid #9ca3af' : undefined }}
                      >
                        {slot.start}-{slot.end}
                      </th>
                    ))
                  )}
                </tr>
              </thead>
              <tbody>
  {allWards.flatMap((ward: any, idx: number, arr: any[]) => {
    // Check if this is the last ward in a directorate
    const isLastInDirectorate = idx < arr.length - 1 && ward.directorate !== arr[idx + 1].directorate;
    
    // Apply directorate separator style
    const rowStyle = isLastInDirectorate ? { borderBottom: '4px solid #9ca3af' } : { borderBottom: '1px solid #e5e7eb' };
    
    return (
      <tr key={ward.directorate + ward.name} className={idx % 2 === 1 ? 'bg-gray-50' : ''}>
        <td className="border p-2 font-semibold sticky left-0 bg-white z-10 truncate max-w-[120px]" style={rowStyle}>{ward.directorate}</td>
        <td className="border p-2 sticky left-0 bg-white z-10 truncate max-w-[120px]" style={rowStyle}>{ward.name}</td>
        {[...Array(5)].flatMap((_, dayOffset: number) => {
          const date = new Date(selectedMonday);
          date.setDate(date.getDate() + dayOffset);
          const isoDate = date.toISOString().split('T')[0];
          return TIME_SLOTS.map((slot: { start: string; end: string }, slotIdx: number) => {
            // Get assignments specifically for this date
            const assignmentsForDate = rotaAssignments.filter(a => a.date === isoDate);
            // Determine the assignments to display in this cell using the standardized logic
            const displayAssignments = getAssignmentsForCell(ward.name, isoDate, slot.start, slot.end, assignmentsForDate);
            // For backward compatibility with existing code
            const displayAssignment = displayAssignments.length > 0 ? displayAssignments[0] : null;

            return (
              <td
                key={isoDate + slot.start + slot.end + ward.name}
                className={`border ${displayAssignments.length > 0 ? 'p-0' : 'p-1'} text-center truncate max-w-[70px] text-xs align-middle whitespace-normal${slotIdx === TIME_SLOTS.length - 1 ? ' border-r-4 border-gray-400' : ''} ${displayAssignments.length === 0 ? 'cursor-pointer hover:bg-gray-100' : ''} ${!isViewOnly && displayAssignments.length > 0 ? 'rota-drag-cell' : ''}`}
                style={{ ...rowStyle, borderRight: slotIdx === TIME_SLOTS.length - 1 ? '4px solid #9ca3af' : undefined, height: '2.5em', minHeight: '2.5em', lineHeight: '1.2', whiteSpace: 'normal', wordBreak: 'break-word', overflow: 'hidden' }}
                onClick={() => displayAssignments.length === 0 && handleEmptyCellClick(ward.name, "ward", isoDate, slot.start, slot.end)}
                onDragOver={(e) => displayAssignments.length > 0 && handleDragOver(e, displayAssignments[0].pharmacistId, displayAssignments[0], ward.name, isoDate, slot.start, slot.end)}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                data-pharmacist-id={displayAssignments.length > 0 ? displayAssignments.map(a => a.pharmacistId).join(',') : ''}
                data-location={ward.name}
                data-date={isoDate}
                data-start-time={slot.start}
                data-end-time={slot.end}
              >
                {displayAssignments.length > 0 ? (
                  <div className="flex flex-col w-full h-full">
                    {displayAssignments.map((assignment, index) => (
                      <div 
                        key={`${assignment.pharmacistId}-${index}`}
                        className={`${getPharmacistCellClass(assignment.pharmacistId)} w-full p-1 flex items-center justify-center ${!isViewOnly ? 'cursor-grab' : ''}`}
                        style={{ height: `${100 / displayAssignments.length}%`, borderTop: index > 0 ? '1px solid rgba(0,0,0,0.1)' : 'none' }}
                        draggable={!isViewOnly}
                        onClick={(e) => {
                          e.stopPropagation(); // Prevent cell click from triggering
                          handleCellClick(assignment, assignment.pharmacistId, slot.start, slot.end);
                        }}
                        onDragStart={(e) => handleDragStart(e, assignment.pharmacistId, assignment, ward.name, isoDate, slot.start, slot.end)}
                        onDragEnd={handleDragEnd}
                      >
                        <span className={`text-center w-full ${hasOverlappingAssignments(assignment.pharmacistId, isoDate, slot) ? 'text-red-600 font-bold' : ''}`}>
                          {getPharmacistName(assignment.pharmacistId)}
                        </span>
                      </div>
                    ))}
                  </div>
                ) : ''}
              </td>
            );
          });
        })}
      </tr>
    );
  })}                

  {/* --- Dispensary --- */}
  <tr>
    <td className="border p-2 font-semibold sticky left-0 bg-white z-10" colSpan={2} style={{ borderTop: '4px solid #9ca3af', borderBottom: '1px solid #e5e7eb' }}>Dispensary</td>
    {[0,1,2,3,4].flatMap((dayOffset: number) => {
      const date = new Date(selectedMonday);
      date.setDate(date.getDate() + dayOffset);
      const isoDate = date.toISOString().split('T')[0];
      return TIME_SLOTS.map((slot, slotIdx) => {
        const assignment = getDispensaryAssignment(isoDate, slot);
        let displayName = '';
        let isLunch = false;
        if (assignment) {
          displayName = getPharmacistName(assignment.pharmacistId);
          // Check if this is a lunch cover assignment, regardless of time slot
          if (assignment.isLunchCover) {
            isLunch = true;
          }
        }
        return (
          <td
            key={dayOffset + '-' + slotIdx}
            className={`border p-1 text-xs bg-gray-50 font-semibold${slotIdx === TIME_SLOTS.length - 1 ? ' border-r-4 border-gray-400' : ''} ${assignment ? getPharmacistCellClass(assignment.pharmacistId) : 'cursor-pointer hover:bg-gray-100'}`}
            style={{ borderTop: '4px solid #9ca3af', borderBottom: '1px solid #e5e7eb', borderRight: slotIdx === TIME_SLOTS.length - 1 ? '4px solid #9ca3af' : undefined, height: '2.5em', minHeight: '2.5em', lineHeight: '1.2', whiteSpace: 'normal', wordBreak: 'break-word' }}
            onClick={() => assignment ? handleCellClick(assignment, assignment.pharmacistId, slot.start, slot.end) : handleEmptyCellClick("Dispensary", "dispensary", isoDate, slot.start, slot.end)}
          >
            {displayName && (
              <div className="text-center">
                <span className={assignment && hasOverlappingAssignments(assignment.pharmacistId, isoDate, slot) ? 'text-red-600 font-bold' : 'text-black font-bold'}>
                  {displayName}{isLunch && " (lunch cover)"}
                </span>
              </div>
            )}
          </td>
        );
      });
    })}
  </tr>
  {sortedSelectedClinics.map((clinic: any, idx: number) => {
    // Highlight all slots that overlap with the clinic's time range
    // Add '(Warfarin Clinic)' after the clinic code in the far left column
    const clinicLabel = `${clinic.name} (Warfarin Clinic)`;
    // Determine if this is the first clinic
    const isFirstClinic = idx === 0;
    // Determine if this is the last clinic
    const isLastClinic = idx === sortedSelectedClinics.length - 1;
    const rowStyle = {
      borderTop: isFirstClinic ? '4px solid #9ca3af' : '1px solid #e5e7eb',
      borderBottom: isLastClinic ? '4px solid #9ca3af' : '1px solid #e5e7eb'
    };
    
    return (
      <tr key={clinic._id}>
        <td className="border p-2 font-semibold sticky left-0 bg-white z-10 truncate max-w-[120px]" style={rowStyle}>{clinicLabel}</td>
        <td className="border p-2 sticky left-0 bg-white z-10 truncate max-w-[120px]" style={rowStyle}>{clinic.name}</td>
        {[...Array(5)].flatMap((_, dayOffset: number) => {
          const date = new Date(selectedMonday);
          date.setDate(date.getDate() + dayOffset);
          const isoDate = date.toISOString().split('T')[0];
          return TIME_SLOTS.map((slot: { start: string; end: string }, slotIdx: number) => {
            const isClinicDay = (dayOffset + 1) === clinic.dayOfWeek;
            // Highlight if slot overlaps with clinic time (inclusive start, exclusive end)
            const slotStart = slot.start;
            const slotEnd = slot.end;
            const overlaps =
              slotStart < clinic.endTime && slotEnd > clinic.startTime;
            if (isClinicDay && overlaps) {
              // Get clinic assignment for this date
              const assignment = getClinicAssignment(isoDate, clinic.name);
              return (
                <td
                  key={isoDate + slot.start + slot.end + clinic._id}
                  className={`border p-1 text-center truncate max-w-[70px] text-xs bg-yellow-100 font-semibold${slotIdx === TIME_SLOTS.length - 1 ? ' border-r-4 border-gray-400' : ''}`}
                  style={{ 
                    ...rowStyle,
                    borderRight: slotIdx === TIME_SLOTS.length - 1 ? '4px solid #9ca3af' : undefined,
                    backgroundColor: assignment ? '#fef9c3' : '#fef9c3', // Maintain yellow background
                    color: '#000' // Always black text for clinics
                  }}
                  onClick={() => assignment && handleCellClick(assignment, assignment.pharmacistId, slot.start, slot.end)}
                >
                  {assignment ? (
                    <span className={hasOverlappingAssignments(assignment.pharmacistId, isoDate, slot) ? 'text-red-600 font-bold' : 'text-black font-bold'}>
                      {getPharmacistName(assignment.pharmacistId)}
                    </span>
                  ) : ""}
                </td>
              );
            } else {
              return <td key={isoDate + slot.start + slot.end + clinic._id} className={`border p-1 text-center max-w-[70px] text-xs bg-gray-50${slotIdx === TIME_SLOTS.length - 1 ? ' border-r-4 border-gray-400' : ''}`} style={{ ...rowStyle, borderRight: slotIdx === TIME_SLOTS.length - 1 ? '4px solid #9ca3af' : undefined }}></td>;
            }
          });
        })}
      </tr>
    );
  })}
</tbody>
              {/* --- Unavailable Pharmacists Row --- */}
              <tfoot>
                <tr>
                  <td colSpan={2} className="border p-2 font-semibold bg-red-50 text-red-700 sticky left-0 z-10" style={{ borderTop: '4px solid #9ca3af', borderBottom: '1px solid #e5e7eb' }}>Unavailable</td>
                  {[0,1,2,3,4].flatMap((dayOffset: number) => {
                    const date = new Date(selectedMonday);
                    date.setDate(date.getDate() + dayOffset);
                    const isoDate = date.toISOString().split('T')[0];
                    return TIME_SLOTS.map((slot, slotIdx) => {
                      // For this slot, get pharmacists unavailable at this day/slot
                      const unavailable = pharmacists.filter((p: any) => {
                        if (!p.notAvailableRules || !Array.isArray(p.notAvailableRules)) return false;
                        return p.notAvailableRules.some((rule: any) =>
                          rule.dayOfWeek === DAYS[date.getDay()] &&
                          !(rule.endTime <= slot.start || rule.startTime >= slot.end)
                        );
                      });
                      return (
                        <td key={dayOffset + '-' + slotIdx} className="border p-1 text-xs bg-red-50 text-red-700 text-center" style={{ borderTop: '4px solid #9ca3af', borderBottom: '1px solid #e5e7eb', borderRight: slotIdx === TIME_SLOTS.length - 1 ? '4px solid #9ca3af' : undefined }}>
                          {unavailable.map((p: any) => p.name).join(', ') || ''}
                        </td>
                      );
                    });
                  })}
                </tr>
                {/* --- Management Time --- */}
                <tr>
                  <td colSpan={2} className="border p-2 font-semibold bg-blue-100 z-10 truncate max-w-[120px]" style={{ borderTop: '4px solid #9ca3af', borderBottom: '1px solid #e5e7eb' }}>Management Time</td>
                  {[0,1,2,3,4].flatMap((dayOffset: number) => {
                    const date = new Date(selectedMonday);
                    date.setDate(date.getDate() + dayOffset);
                    const isoDate = date.toISOString().split('T')[0];
                    return TIME_SLOTS.map((slot, slotIdx) => {
                      // Find Band 8a pharmacists in Management Time for this date/slot
                      const managementAssignments = rotaAssignments.filter(a => 
                        a.type === "management" && 
                        a.date === isoDate && 
                        ((a.startTime <= slot.start && a.endTime > slot.start) || 
                         (a.startTime < slot.end && a.endTime >= slot.end) ||
                         (a.startTime >= slot.start && a.endTime <= slot.end))
                      );
                      
                      // Get pharmacist names
                      const pharmacistNames = managementAssignments.map(a => getPharmacistName(a.pharmacistId)).filter(Boolean);
                      
                      return (
                        <td
                          key={isoDate + slot.start + slot.end + 'management'}
                          className={`border p-1 text-center max-w-[70px] text-xs bg-blue-50${slotIdx === TIME_SLOTS.length - 1 ? ' border-r-4 border-gray-400' : ''}`} 
                          style={{ borderTop: '4px solid #9ca3af', borderBottom: '1px solid #e5e7eb', borderRight: slotIdx === TIME_SLOTS.length - 1 ? '4px solid #9ca3af' : undefined, height: '2.5em', minHeight: '2.5em', lineHeight: '1.2', whiteSpace: 'normal', wordBreak: 'break-word' }}
                        >
                          {pharmacistNames.length > 0 ? (
                            <span>{pharmacistNames.join(", ")}</span>
                          ) : null}
                        </td>
                      );
                    });
                  })}
                </tr>
              </tfoot>
            </table>
          </div>
        </div>
      )}
      {/* Add the PharmacistSelectionModal - only shown when not in view-only mode */}
      {!isViewOnly && showPharmacistSelection && selectedCell && (
        <PharmacistSelectionModal
          isOpen={showPharmacistSelection}
          onClose={() => {
            setShowPharmacistSelection(false);
            setSelectedCell(null);
          }}
          onSelect={handlePharmacistSelect}
          currentPharmacistId={selectedCell.currentPharmacistId}
          location={selectedCell.location}
        />
      )}
    </div>
  );
}
